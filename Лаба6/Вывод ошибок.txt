#include <iostream>
#include <vector>
#include <cmath>
#include <string>
#include <algorithm>
#include <map>
#include <unordered_map>
#include <queue>
#include <stack>
#include <numeric>
#include <set>

using namespace std;

const double nx = 30;
const double l = acos(-1.);
const double t = 30;

const double a = 1;
const double c = -1;
const double sigma = 0.25;  // число Куранта

double h = l / nx;
double tau = h * h * sigma / a;
double nt = ceil(t / tau);


double func(double x, double t) {
    return cos(x) * exp(0. - t);
}

vector<double> make_start() {
    vector<double> zero_lvl(nx + 1);
    for (int i = 0; i < nx + 1; i++) {
        zero_lvl[i] = sin(double(i) * h);
    }
    return zero_lvl;
}

vector<double> make_start_1() {
    vector<double> first_lvl(nx + 1);
    for (int i = 0; i < nx + 1; i++) {
        first_lvl[i] = sin(double(i) * h) - sin(double(i) * h) * tau;
    }
    return first_lvl;
}

vector<double> make_start_2() {
    vector<double> first_lvl(nx + 1);
    for (int i = 0; i < nx + 1; i++) {
        first_lvl[i] = sin(double(i) * h) - sin(double(i) * h) * tau + sin(double(i) * h) * tau * tau / 2.;
    }
    return first_lvl;
}

vector<double> line_minus(vector<double> aa, vector<double> b, int k) {
    double coef = aa[k] / b[k];
    int st;
    int fin;
    if (k == 2) {
        st = k - 2;
        fin = k;
    }
    else {
        st = k;
        fin = k + 2;
    }
    for (int i = st;i <= fin;i++) {
        aa[i] = aa[i] - b[i] * coef;
    }
    return aa;
}


vector<double> sweep_meth(vector<vector<double>> v, vector<double> b) {
    int n = v.size();
    double coef;
    vector<double> ans(n);
    for (int i = 0;i < n - 1;i++) {
        coef = v[i + 1][i] / v[i][i];
        for (int j = i; j < i + 2;j++) {
            v[i + 1][j] = v[i + 1][j] - v[i][j] * coef;
        }
        b[i + 1] = b[i + 1] - b[i] * coef;
    }
    ans[n - 1] = b[n - 1] / v[n - 1][n - 1];
    for (int i = n - 2;i > -1;i--) {
        b[i] = b[i] - v[i][i + 1] * ans[i + 1];
        ans[i] = b[i] / v[i][i];
    }
    return ans;
}

vector<vector<double>> true_values() {
    vector<vector<double>> U(nt + 1, vector<double>(nx + 1));
    for (int i = 0;i < nt + 1;i++) {
        for (int j = 0;j < nx + 1;j++) {
            U[i][j] = exp(0. - double(i) * tau) * sin(h * double(j));
        }
    }
    return U;
}

//explicit

vector<vector<double>> expl_meth_1(vector<double> zero_lvl, vector<double> first_lvl) {
    vector<vector<double>> U(nt + 1, vector<double>(nx + 1));
    U[0] = zero_lvl;
    U[1] = first_lvl;
    for (int k = 1;k < nt;k++) {
        for (int i = 1;i < nx;i++) {
            U[k + 1][i] = ((U[k][i - 1] - 2. * U[k][i] + U[k][i + 1]) / (h * h) + (U[k][i + 1] - U[k][i - 1]) / (2. * h) - U[k][i]
                - func(double(i) * h, tau * double(k)) + (3. * U[k - 1][i]) / (2. * tau) + (2. * U[k][i] - U[k - 1][i]) / (tau * tau))
                / (1. / (tau * tau) + 3. / (2. * tau));
        }
        U[k + 1][0] = U[k + 1][1] - h * exp(0. - tau * double(k + 1.));
        U[k + 1][nx] = U[k + 1][nx - 1] - h * exp(0. - tau * double(k + 1.));
    }
    return U;
}

vector<vector<double>> expl_meth_2(vector<double> zero_lvl, vector<double> first_lvl) {
    vector<vector<double>> U(nt + 1, vector<double>(nx + 1));
    U[0] = zero_lvl;
    U[1] = first_lvl;
    for (int k = 1;k < nt;k++) {
        for (int i = 1;i < nx;i++) {
            U[k + 1][i] = ((U[k][i - 1] - 2. * U[k][i] + U[k][i + 1]) / (h * h) + (U[k][i + 1] - U[k][i - 1]) / (2. * h) - U[k][i]
                - func(double(i) * h, tau * double(k)) + (3. * U[k - 1][i]) / (2. * tau) + (2. * U[k][i] - U[k - 1][i]) / (tau * tau))
                / (1. / (tau * tau) + 3. / (2. * tau));
        }
        U[k + 1][0] = (4. * U[k + 1][1] - U[k + 1][2]) / 3. - 2. * h * exp(0 - tau * double(k + 1.)) / 3.;
        U[k + 1][nx] = (4. * U[k + 1][nx - 1] - U[k + 1][nx - 2]) / 3. - 2. * h * exp(-tau * double(k + 1.)) / 3.;
    }
    return U;
}

vector<vector<double>> expl_meth_3(vector<double> zero_lvl, vector<double> first_lvl) {
    vector<vector<double>> U(nt + 1, vector<double>(nx + 1));
    U[0] = zero_lvl;
    U[1] = first_lvl;
    for (int k = 1;k < nt;k++) {
        for (int i = 1;i < nx;i++) {
            U[k + 1][i] = ((U[k][i - 1] - 2. * U[k][i] + U[k][i + 1]) / (h * h) + (U[k][i + 1] - U[k][i - 1]) / (2. * h) - U[k][i]
                - func(double(i) * h, tau * double(k)) + (3. * U[k - 1][i]) / (2. * tau) + (2. * U[k][i] - U[k - 1][i]) / (tau * tau))
                / (1. / (tau * tau) + 3. / (2. * tau));
        }
        U[k + 1][0] = (exp(-tau * double(k + 1.)) - (U[k][1] - U[k][0]) / (h - h * h / 2.)
            + h * h / (2. * (h - h * h / 2.)) * (U[k - 1][0] - 2. * U[k][0]) / (tau * tau)
            - 3. * h * h / (2. * (h - h * h / 2.)) * U[k - 1][0] / (2. * tau) + U[k][0] * h * h / 2. / (h - h * h / 2.)
            + func(0., double(tau * k)) * h * h / 2. / (h - h * h / 2.))
            / (0. - h * h / (2. * (h - h * h / 2.) * tau * tau) - 3. * h * h / (2. * (h - h * h / 2.) * tau * 2.));

        U[k + 1][nx] = (0. - exp(-tau * double(k + 1.)) + (U[k][nx - 1] - U[k][nx]) / (h + h * h / 2.)
            - h * h / (2. * (h + h * h / 2.)) * (U[k - 1][nx] - 2. * U[k][nx]) / (tau * tau)
            + 3. * h * h / (2. * (h + h * h / 2.)) * U[k - 1][nx] / (2. * tau) - U[k][nx] * h * h / 2. / (h + h * h / 2.)
            - func(double(nx) * h, tau * k) * h * h / 2. / (h + h * h / 2.))
            / (h * h / (2. * (h + h * h / 2.) * tau * tau) + 3. * h * h / (2. * (h + h * h / 2.) * tau * 2.));

    }
    return U;
}


//implicit

vector<vector<double>> impl_meth_1(vector<double> zero_lvl, vector<double> first_lvl) {
    vector<vector<double>> U(nt + 1, vector<double>(nx + 1));
    U[0] = zero_lvl;
    U[1] = first_lvl;
    vector<vector<double>> A(nx + 1, vector<double>(nx + 1));
    vector<double> b(nx + 1);

    for (int k = 1;k < nt;k++) {
        A[0][0] = 1.;
        A[0][1] = -1.;
        b[0] = 0. - h * exp(0. - double(k + 1) * tau);

        for (int i = 1; i < nx; i++) {
            A[i][i - 1] = 0. - 1. / (h * h) + 1. / (2. * h);
            A[i][i] = 1. / (tau * tau) + 3. / (2. * tau) + 2. / (h * h) + 1.;
            A[i][i + 1] = 0. - 1. / (h * h) - 1. / (2. * h);
            b[i] = 3. * U[k - 1][i] / (2. * tau) + (2. * U[k][i] - U[k - 1][i]) / (tau * tau) - func(double(i) * h, tau * double(k + 1.));
        }

        A[nx][nx] = 1.;
        A[nx][nx - 1] = -1.;
        b[nx] = 0. - h * exp(0. - double(k + 1) * tau);

        U[k + 1] = sweep_meth(A, b);
    }
    return U;
}

vector<vector<double>> impl_meth_2(vector<double> zero_lvl, vector<double> first_lvl) {
    vector<vector<double>> U(nt + 1, vector<double>(nx + 1));
    U[0] = zero_lvl;
    U[1] = first_lvl;
    vector<vector<double>> A(nx + 1, vector<double>(nx + 1));
    vector<double> b(nx + 1);

    for (int k = 1;k < nt;k++) {
        A[0][0] = 1.;
        A[0][1] = -4. / 3.;
        A[0][2] = 1. / 3.;
        b[0] = 0 - 2. * h / 3. * exp(0. - double(k + 1) * tau);

        for (int i = 1; i < nx; i++) {
            A[i][i - 1] = 0. - 1. / (h * h) + 1. / (2. * h);
            A[i][i] = 1. / (tau * tau) + 3. / (2. * tau) + 2. / (h * h) + 1.;
            A[i][i + 1] = 0. - 1. / (h * h) - 1. / (2. * h);
            b[i] = 3. * U[k - 1][i] / (2. * tau) + (2. * U[k][i] - U[k - 1][i]) / (tau * tau) - func(double(i) * h, tau * double(k + 1.));
        }

        A[nx][nx] = 1.;
        A[nx][nx - 1] = -4. / 3.;
        A[nx][nx - 2] = 1. / 3.;
        b[nx] = 0 - 2. * h / 3. * exp(0. - double(k + 1) * tau);

        b[0] = b[0] - A[0][2] / A[1][2] * b[1];
        b[nx] = b[nx] - A[nx][nx - 2] / A[nx - 1][nx - 2] * b[nx - 1];

        A[0] = line_minus(A[0], A[1], 2);
        A[nx] = line_minus(A[nx], A[nx - 1], nx - 2);

        U[k + 1] = sweep_meth(A, b);
    }
    return U;
}

vector<vector<double>> impl_meth_3(vector<double> zero_lvl, vector<double> first_lvl) {
    vector<vector<double>> U(nt + 1, vector<double>(nx + 1));
    U[0] = zero_lvl;
    U[1] = first_lvl;
    vector<vector<double>> A(nx + 1, vector<double>(nx + 1));
    vector<double> b(nx + 1);

    for (int k = 1;k < nt;k++) {
        A[0][0] = (0. - h * h / (2. * (h - h * h / 2.) * tau * tau) - 3. * h * h / (2. * (h - h * h / 2.) * tau * 2.) - 1. / (h - h * h / 2.));
        A[0][1] = 1. / (h - h * h / 2.);
        b[0] = (exp(0. - tau * double(k + 1.))
            + h * h / (2. * (h - h * h / 2.)) * (U[k - 1][0] - 2. * U[k][0]) / (tau * tau)
            - 3. * h * h / (2. * (h - h * h / 2.)) * U[k - 1][0] / (2. * tau) + U[k][0] * h * h / 2. / (h - h * h / 2.)
            + func(0., tau * double(k + 1)) * h * h / 2. / (h - h * h / 2.));

        for (int i = 1; i < nx; i++) {
            A[i][i - 1] = 0. - 1. / (h * h) + 1. / (2. * h);
            A[i][i] = 1. / (tau * tau) + 3. / (2. * tau) + 2. / (h * h) + 1.;
            A[i][i + 1] = 0. - 1. / (h * h) - 1. / (2. * h);
            b[i] = 3. * U[k - 1][i] / (2. * tau) + (2. * U[k][i] - U[k - 1][i]) / (tau * tau) - func(double(i) * h, tau * double(k + 1.));
        }

        A[nx][nx] = (h * h / (2. * (h + h * h / 2.) * tau * tau) + 3. * h * h / (2. * (h + h * h / 2.) * tau * 2.) + 1. / (h + h * h / 2.));
        A[nx][nx - 1] = 0 - 1. / (h + h * h / 2.);
        b[nx] = (0. - exp(-tau * double(k + 1.))
            - h * h / (2. * (h + h * h / 2.)) * (U[k - 1][nx] - 2. * U[k][nx]) / (tau * tau)
            + 3. * h * h / (2. * (h + h * h / 2.)) * U[k - 1][nx] / (2. * tau) - U[k][nx] * h * h / 2. / (h + h * h / 2.)
            - func(double(nx) * h, tau * double(k + 1)) * h * h / 2. / (h + h * h / 2.));

        U[k + 1] = sweep_meth(A, b);
    }
    return U;
}

int main() {
    vector<double> zero_lvl = make_start();
    vector<double> first_lvl_1 = make_start_1();
    vector<double> first_lvl_2 = make_start_2();
    vector<vector<double>> U;
    vector<vector<double>> U_T;
    double mx;
    U_T = true_values();

    U = expl_meth_1(zero_lvl, first_lvl_1);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = expl_meth_1(zero_lvl, first_lvl_2);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = expl_meth_2(zero_lvl, first_lvl_1);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = expl_meth_2(zero_lvl, first_lvl_2);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = expl_meth_3(zero_lvl, first_lvl_1);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = expl_meth_3(zero_lvl, first_lvl_2);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = impl_meth_1(zero_lvl, first_lvl_1);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = impl_meth_1(zero_lvl, first_lvl_2);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = impl_meth_2(zero_lvl, first_lvl_1);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = impl_meth_2(zero_lvl, first_lvl_2);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = impl_meth_3(zero_lvl, first_lvl_1);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';

    U = impl_meth_3(zero_lvl, first_lvl_2);
    for (int g = 0; g < nt + 1; g++) {
        mx = 0;
        for (int j = 0;j < nx + 1;j++) {
            mx = max(mx, abs(U_T[g][j] - U[g][j]));
        }
        cout << mx << ' ';
    }
    cout << '\n';
}